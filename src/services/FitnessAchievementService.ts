/**
 * Fitness Achievement Service
 * 
 * Service for tracking and managing fitness-specific achievements.
 * Integrates with workout data, personal records, and user statistics.
 */

import { logger } from '@/utils/logger';
import { IndexedDBManager } from '@/db/IndexedDBManager';
import { AchievementEngine } from './AchievementEngine';
import { GamificationService } from './GamificationService';
import { allFitnessAchievements } from '@/data/fitnessAchievements';
import { validateFitnessAchievement, type AchievementValidationContext } from '@/utils/fitnessAchievementValidators';
import type {
  Achievement,
  UserAchievement,
  GamificationStats,
  GamificationEvent
} from '@/types/gamification';
import type { Workout } from '@/types/workout';
import type { PersonalRecord } from '@/types/analytics';

export interface FitnessAchievementContext {
  workout?: Workout;
  personalRecord?: PersonalRecord;
  userProfile?: {
    weight?: number;
    height?: number;
    age?: number;
    gender?: string;
  };
  workoutHistory?: Workout[];
  personalRecords?: PersonalRecord[];
}

export interface FitnessAchievementResult {
  checkedAchievements: number;
  unlockedAchievements: Achievement[];
  progressUpdates: Array<{
    achievement: Achievement;
    previousProgress: number;
    newProgress: number;
  }>;
  errors: string[];
}

export class FitnessAchievementService {
  private static instance: FitnessAchievementService;
  private db: IndexedDBManager;
  private achievementEngine: AchievementEngine;
  private gamificationService: GamificationService;

  private constructor() {
    this.db = IndexedDBManager.getInstance();
    this.achievementEngine = AchievementEngine.getInstance();
    this.gamificationService = GamificationService.getInstance();
  }

  public static getInstance(): FitnessAchievementService {
    if (!FitnessAchievementService.instance) {
      FitnessAchievementService.instance = new FitnessAchievementService();
    }
    return FitnessAchievementService.instance;
  }

  // ============================================================================
  // Workout-Based Achievement Checking
  // ============================================================================

  /**
   * Check achievements after workout completion
   */
  async checkWorkoutAchievements(
    userId: string,
    workout: Workout,
    context: FitnessAchievementContext = {}
  ): Promise<FitnessAchievementResult> {
    try {
      logger.info(`Checking workout achievements for user ${userId}`);\n\n      // Get user stats and context data\n      const [userStats, userProfile, workoutHistory, personalRecords] = await Promise.all([\n        this.gamificationService.getUserStats(userId),\n        this.getUserProfile(userId),\n        this.getRecentWorkouts(userId, 30), // Last 30 workouts\n        this.getPersonalRecords(userId)\n      ]);\n\n      // Update stats based on current workout\n      const updatedStats = this.updateStatsWithWorkout(userStats, workout, workoutHistory);\n\n      // Create validation context\n      const validationContext: AchievementValidationContext = {\n        userStats: updatedStats,\n        personalRecords,\n        userProfile: context.userProfile || userProfile,\n        eventData: {\n          workout,\n          workoutHistory,\n          personalRecords,\n          ...context\n        }\n      };\n\n      // Check relevant achievements\n      const relevantAchievements = this.getWorkoutRelevantAchievements();\n      return await this.checkAchievementList(userId, relevantAchievements, validationContext);\n    } catch (error) {\n      logger.error('Error checking workout achievements:', error);\n      return {\n        checkedAchievements: 0,\n        unlockedAchievements: [],\n        progressUpdates: [],\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  }\n\n  /**\n   * Check achievements after personal record\n   */\n  async checkPersonalRecordAchievements(\n    userId: string,\n    personalRecord: PersonalRecord,\n    context: FitnessAchievementContext = {}\n  ): Promise<FitnessAchievementResult> {\n    try {\n      logger.info(`Checking PR achievements for user ${userId}`);\n\n      // Get user stats and context data\n      const [userStats, userProfile, personalRecords] = await Promise.all([\n        this.gamificationService.getUserStats(userId),\n        this.getUserProfile(userId),\n        this.getPersonalRecords(userId)\n      ]);\n\n      // Add new PR to the list\n      const updatedPersonalRecords = [...personalRecords, personalRecord];\n\n      // Update stats with new PR\n      const updatedStats = this.updateStatsWithPersonalRecord(userStats, personalRecord, updatedPersonalRecords);\n\n      // Create validation context\n      const validationContext: AchievementValidationContext = {\n        userStats: updatedStats,\n        personalRecords: updatedPersonalRecords,\n        userProfile: context.userProfile || userProfile,\n        eventData: {\n          personalRecord,\n          personalRecords: updatedPersonalRecords,\n          ...context\n        }\n      };\n\n      // Check relevant achievements\n      const relevantAchievements = this.getStrengthRelevantAchievements();\n      return await this.checkAchievementList(userId, relevantAchievements, validationContext);\n    } catch (error) {\n      logger.error('Error checking PR achievements:', error);\n      return {\n        checkedAchievements: 0,\n        unlockedAchievements: [],\n        progressUpdates: [],\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  }\n\n  /**\n   * Check achievements for streak milestones\n   */\n  async checkStreakAchievements(\n    userId: string,\n    streakDays: number,\n    context: FitnessAchievementContext = {}\n  ): Promise<FitnessAchievementResult> {\n    try {\n      logger.info(`Checking streak achievements for user ${userId}`);\n\n      // Get user stats\n      const userStats = await this.gamificationService.getUserStats(userId);\n      const userProfile = await this.getUserProfile(userId);\n\n      // Update stats with current streak\n      const updatedStats = {\n        ...userStats,\n        currentStreak: streakDays,\n        longestStreak: Math.max(userStats.longestStreak || 0, streakDays)\n      };\n\n      // Create validation context\n      const validationContext: AchievementValidationContext = {\n        userStats: updatedStats,\n        personalRecords: context.personalRecords || [],\n        userProfile: context.userProfile || userProfile,\n        eventData: {\n          streakDays,\n          ...context\n        }\n      };\n\n      // Check streak achievements\n      const streakAchievements = allFitnessAchievements.filter(a => \n        a.requirements.type === 'streak_days'\n      );\n      \n      return await this.checkAchievementList(userId, streakAchievements, validationContext);\n    } catch (error) {\n      logger.error('Error checking streak achievements:', error);\n      return {\n        checkedAchievements: 0,\n        unlockedAchievements: [],\n        progressUpdates: [],\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  }\n\n  // ============================================================================\n  // Achievement List Processing\n  // ============================================================================\n\n  /**\n   * Check a list of achievements for a user\n   */\n  private async checkAchievementList(\n    userId: string,\n    achievements: Achievement[],\n    context: AchievementValidationContext\n  ): Promise<FitnessAchievementResult> {\n    const result: FitnessAchievementResult = {\n      checkedAchievements: achievements.length,\n      unlockedAchievements: [],\n      progressUpdates: [],\n      errors: []\n    };\n\n    // Get current user achievements\n    const userAchievements = await this.achievementEngine.getUserAchievements(userId);\n    const userAchievementMap = new Map(\n      userAchievements.map(ua => [ua.achievementId, ua])\n    );\n\n    // Process each achievement\n    for (const achievement of achievements) {\n      try {\n        const userAchievement = userAchievementMap.get(achievement.id);\n        if (!userAchievement) continue;\n\n        // Skip if already unlocked and not repeatable\n        if (userAchievement.isUnlocked && !achievement.isRepeatable) {\n          continue;\n        }\n\n        const previousProgress = userAchievement.progress;\n        const validationResult = validateFitnessAchievement(achievement, userAchievement, context);\n\n        // Check if achievement was just unlocked\n        if (validationResult.isUnlocked && !userAchievement.isUnlocked) {\n          result.unlockedAchievements.push(achievement);\n          \n          // Award XP\n          if (achievement.rewards.xp > 0) {\n            await this.gamificationService.awardXP(\n              userId,\n              achievement.rewards.xp,\n              'achievement_unlock',\n              achievement.id\n            );\n          }\n\n          logger.info(`Achievement unlocked: ${achievement.name} for user ${userId}`);\n        }\n\n        // Track progress updates\n        if (Math.abs(validationResult.progress - previousProgress) > 0.01) {\n          result.progressUpdates.push({\n            achievement,\n            previousProgress,\n            newProgress: validationResult.progress\n          });\n        }\n\n        // Update user achievement in database\n        const updatedUserAchievement = {\n          ...userAchievement,\n          progress: validationResult.progress,\n          isUnlocked: validationResult.isUnlocked,\n          currentValues: {\n            [achievement.requirements.type]: validationResult.currentValue,\n            ...validationResult.metadata\n          },\n          unlockedAt: validationResult.isUnlocked && !userAchievement.isUnlocked ? new Date() : userAchievement.unlockedAt,\n          timesCompleted: validationResult.isUnlocked && achievement.isRepeatable \n            ? userAchievement.timesCompleted + 1 \n            : userAchievement.timesCompleted\n        };\n\n        await this.db.update('user_achievements', `${userId}_${achievement.id}`, updatedUserAchievement);\n      } catch (error) {\n        const errorMsg = `Error processing achievement ${achievement.id}: ${error}`;\n        logger.error(errorMsg);\n        result.errors.push(errorMsg);\n      }\n    }\n\n    return result;\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  /**\n   * Get achievements relevant to workout completion\n   */\n  private getWorkoutRelevantAchievements(): Achievement[] {\n    return allFitnessAchievements.filter(achievement => {\n      const type = achievement.requirements.type;\n      return [\n        'workout_count',\n        'streak_days',\n        'workouts_per_week',\n        'total_workout_time_hours',\n        'early_workouts',\n        'late_workouts',\n        'short_workouts',\n        'long_workout_minutes',\n        'midnight_workout',\n        'unique_exercises',\n        'muscle_groups_per_week',\n        'days_since_first_workout',\n        'total_volume_kg'\n      ].includes(type);\n    });\n  }\n\n  /**\n   * Get achievements relevant to strength/PRs\n   */\n  private getStrengthRelevantAchievements(): Achievement[] {\n    return allFitnessAchievements.filter(achievement => {\n      const type = achievement.requirements.type;\n      return [\n        'personal_records',\n        'total_volume_kg',\n        'bench_press_bodyweight_ratio',\n        'squat_bodyweight_ratio',\n        'deadlift_bodyweight_ratio'\n      ].includes(type);\n    });\n  }\n\n  /**\n   * Update user stats with workout data\n   */\n  private updateStatsWithWorkout(\n    userStats: GamificationStats,\n    workout: Workout,\n    workoutHistory: Workout[]\n  ): GamificationStats {\n    const workoutDate = new Date(workout.completedAt || Date.now());\n    const workoutHour = workoutDate.getHours();\n    const workoutDuration = workout.duration || 0;\n    \n    // Calculate total volume for this workout\n    const workoutVolume = workout.exercises.reduce((total, exercise) => {\n      return total + exercise.sets.reduce((setTotal, set) => {\n        return setTotal + (set.weight || 0) * (set.reps || 0);\n      }, 0);\n    }, 0);\n\n    // Get unique exercises from this workout\n    const workoutExercises = new Set(workout.exercises.map(e => e.exerciseId));\n    \n    // Get all unique exercises from history\n    const allExercises = new Set([\n      ...workoutHistory.flatMap(w => w.exercises.map(e => e.exerciseId)),\n      ...workoutExercises\n    ]);\n\n    // Calculate muscle groups worked this week\n    const thisWeekStart = new Date();\n    thisWeekStart.setDate(thisWeekStart.getDate() - thisWeekStart.getDay());\n    thisWeekStart.setHours(0, 0, 0, 0);\n    \n    const thisWeekWorkouts = workoutHistory.filter(w => \n      new Date(w.completedAt || 0) >= thisWeekStart\n    );\n    thisWeekWorkouts.push(workout);\n    \n    const muscleGroupsThisWeek = new Set(\n      thisWeekWorkouts.flatMap(w => \n        w.exercises.flatMap(e => e.muscleGroups || [])\n      )\n    ).size;\n\n    return {\n      ...userStats,\n      totalWorkouts: (userStats.totalWorkouts || 0) + 1,\n      totalWorkoutTimeMinutes: (userStats.totalWorkoutTimeMinutes || 0) + workoutDuration,\n      totalVolumeKg: (userStats.totalVolumeKg || 0) + workoutVolume,\n      uniqueExercises: allExercises.size,\n      muscleGroupsThisWeek,\n      workoutsThisWeek: thisWeekWorkouts.length,\n      earlyWorkouts: (userStats.earlyWorkouts || 0) + (workoutHour < 7 ? 1 : 0),\n      lateWorkouts: (userStats.lateWorkouts || 0) + (workoutHour >= 21 ? 1 : 0),\n      shortWorkouts: (userStats.shortWorkouts || 0) + (workoutDuration < 30 ? 1 : 0),\n      longestWorkoutMinutes: Math.max(userStats.longestWorkoutMinutes || 0, workoutDuration),\n      midnightWorkouts: (userStats.midnightWorkouts || 0) + (workoutHour === 0 ? 1 : 0),\n      firstWorkoutDate: userStats.firstWorkoutDate || workoutDate\n    };\n  }\n\n  /**\n   * Update user stats with personal record data\n   */\n  private updateStatsWithPersonalRecord(\n    userStats: GamificationStats,\n    personalRecord: PersonalRecord,\n    allPersonalRecords: PersonalRecord[]\n  ): GamificationStats {\n    return {\n      ...userStats,\n      personalRecords: allPersonalRecords.length\n    };\n  }\n\n  /**\n   * Get user profile data\n   */\n  private async getUserProfile(userId: string): Promise<any> {\n    try {\n      const profile = await this.db.get('user_profiles', userId);\n      return profile || {};\n    } catch (error) {\n      logger.warn('Could not load user profile:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Get recent workouts for a user\n   */\n  private async getRecentWorkouts(userId: string, limit: number = 30): Promise<Workout[]> {\n    try {\n      const workouts = await this.db.getAll('workouts', {\n        index: 'userId',\n        value: userId\n      });\n      \n      return workouts\n        .filter(w => w.completedAt)\n        .sort((a, b) => new Date(b.completedAt!).getTime() - new Date(a.completedAt!).getTime())\n        .slice(0, limit);\n    } catch (error) {\n      logger.warn('Could not load recent workouts:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get personal records for a user\n   */\n  private async getPersonalRecords(userId: string): Promise<PersonalRecord[]> {\n    try {\n      const records = await this.db.getAll('personal_records', {\n        index: 'userId',\n        value: userId\n      });\n      return records || [];\n    } catch (error) {\n      logger.warn('Could not load personal records:', error);\n      return [];\n    }\n  }\n\n  // ============================================================================\n  // Public Utility Methods\n  // ============================================================================\n\n  /**\n   * Get all fitness achievements\n   */\n  getFitnessAchievements(): Achievement[] {\n    return allFitnessAchievements;\n  }\n\n  /**\n   * Get achievements by category\n   */\n  getAchievementsByCategory(category: string): Achievement[] {\n    return allFitnessAchievements.filter(a => a.category === category);\n  }\n\n  /**\n   * Get achievements by rarity\n   */\n  getAchievementsByRarity(rarity: string): Achievement[] {\n    return allFitnessAchievements.filter(a => a.rarity === rarity);\n  }\n\n  /**\n   * Manually trigger achievement check for testing\n   */\n  async triggerAchievementCheck(\n    userId: string,\n    achievementIds: string[],\n    context: FitnessAchievementContext = {}\n  ): Promise<FitnessAchievementResult> {\n    const achievements = allFitnessAchievements.filter(a => achievementIds.includes(a.id));\n    \n    const userStats = await this.gamificationService.getUserStats(userId);\n    const userProfile = await this.getUserProfile(userId);\n    const personalRecords = await this.getPersonalRecords(userId);\n    \n    const validationContext: AchievementValidationContext = {\n      userStats,\n      personalRecords,\n      userProfile,\n      eventData: context\n    };\n    \n    return await this.checkAchievementList(userId, achievements, validationContext);\n  }\n}\n\nexport default FitnessAchievementService;"